package templates

// EchoUsecaseTmpl : is tmpl to create app
var EchoUsecaseTmpl = `// Code generated by Mestri; DO NOT EDIT.
// This file was generated by Mestri robots at
// {{ .Timestamp }}
package {{ .Entity }}
import (
	"context"
	"time"
	"github.com/heraju/mestri/app/helpers"
	
)


type usecase struct {
	repo	Repository
	contextTimeout	time.Duration
}

// NewUsecase will create new an articleUsecase object representation of Usecase interface
func NewUsecase(a Repository, timeout time.Duration) Usecase {
	return &usecase{
		repo:    a,
		contextTimeout: timeout,
	}
}

func (a *usecase) Index(c context.Context, cursor string, num int64) (res []Entity, nextCursor string, err error) {
	if num == 0 {
		num = 10
	}

	ctx, cancel := context.WithTimeout(c, a.contextTimeout)
	defer cancel()

	res, nextCursor, err = a.repo.Index(ctx, cursor, num)
	if err != nil {
		return nil, "", err
	}

	if err != nil {
		nextCursor = ""
	}
	return
}

func (a *usecase) Get(c context.Context, id {{.IdType}}) (res Entity, err error) {
	ctx, cancel := context.WithTimeout(c, a.contextTimeout)
	defer cancel()

	res, err = a.repo.Get(ctx, id)
	if err != nil {
		return
	}
	
	if err != nil {
		return Entity{}, err
	}
	
	return
}

func (a *usecase) Update(c context.Context, en *Entity, id {{.IdType}}) (err error) {
	ctx, cancel := context.WithTimeout(c, a.contextTimeout)
	defer cancel()

	return a.repo.Update(ctx, en, id)
}

func (a *usecase) Create(c context.Context, en *Entity) (err error) {
	ctx, cancel := context.WithTimeout(c, a.contextTimeout)
	defer cancel()
	
	err = a.repo.Create(ctx, en)
	return
}

func (a *usecase) Delete(c context.Context, id {{.IdType}}) (err error) {
	ctx, cancel := context.WithTimeout(c, a.contextTimeout)
	defer cancel()
	existedEntity, err := a.repo.Get(ctx, id)
	if err != nil {
		return
	}
	if existedEntity == (Entity{}) {
		return helpers.ErrNotFound
	}
	return a.repo.Delete(ctx, id)
}
`
